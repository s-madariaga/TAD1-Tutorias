---
title: "Taller 1: Introducción y estructura de datos"
author: "Sofía Madariaga <samadariaga@uc.cl>"
format: html
editor: visual
theme: darkly
---

```{=html}
<style>
img {
  padding:20px;
}
</style>
```
## Introducción

-   R es un **lenguaje de programación** enfocado únicamente a **estadística**.

    -   Trabajar con un lenguaje de programación significa trabajar con una herramienta altamente personalizable, por lo que requiere un poco de estudio autodidácta y práctica para memorizar y aclimatarse a las mecáncias. Además, cada usuario tiene su estilo y funciones recurrentes. Hay más de una forma de lograr un objetivo en particular.

-   **Rstudio** es su entorno de desarrollo integrado (IDE). Con él podemos trabajar más adecuadamente con **herramientas para la gestión de objetos** (bases de datos, vectores, constantes, resultados, etc), **visualizaciones** y otras herramientas que facilitan el trabajo.

-   Trabajaremos con **R** desde **Rstudio**.

::: {style="display:inline;"}
<img src="R.png" width="200"/> <img src="rstudio.png" width="350"/>
:::

## Rstudio

-   En **Rstudio** encuentro 4 paneles:

    -   **Consola:** donde se ejecutan lso comandos.

    -   **Script:** donde voydejando registro de los comandos en un archivo de "texto", con la extensión R.

    -   **Paneles de la izquierda:**

        -   Panel de **enviroment** y **visualización de documentos**.

        -   Panel de **directorio de archivos**, **visualización de gráficos** y **documentación**.

## ¡Empecemos!

### Sintaxis básica

-   Los **comentarios** son antecedidos por `#`.

-   Los comandos se van ejecutando por línea y en un **flujo de ejecución vertical**.

-   Con `;` puedo ejecutar dos comandos en una misma línea.

-   Un signo "+" en la consola, se debe a que todavía no he terminado una instrucción.

```{r, eval=FALSE}
# Esto es un comentario

#* Esto es un comentario continuo

print("hola") ; print("chao")
```

```{r, echo=FALSE}
# Esto es un comentario

#* Esto es un comentario continuo

print("hola") ; print("chao")
```

### 1. Objetos en R

-   R es un lenguaje de programación **orientado a objetos**.

-   En palabras simples, significa que podemos guardar nuestros resultados, estructuras de datos y valores en un espacio de memoria y este espacio de memoria debe tener un nombre.

    ```{r}
    pi <- 3.14
    pi = 3.14
    ```

    Luego, estos objetos pueden interaccionar entre sí.

    ```{r}
    pi <- 3.14
    pi = 3.14
    radio <- 2

    radio*pi**2
    ```

    Reglas a la hora de declarar una variable:

    -   No puede empezar con un número.

    -   No puede tener espacios entre medio.

    -   Evitar los carácteres extraños como tildes y ñ.

    -   Estilos:

        -   `snake_case`

        -   `camelCase`

        -   `PascalCase`

        ```{r}
        area_circulo <- radio*pi**2
        ```

### 2. Fijar directorio

-   FIjamos el directorio, para tener un acceso a los archivos de una carpeta en particular.

-   Estamos diciendo a R que vamos a trabajar en esa carpeta.

-   Los **proyectos** fijan el ditectorio de manera automática como la carpeta en la que se encuentra el archivo de proyecto (`.Rproj`).

```{r, eval = FALSE}
getwd()
setwd("/home/sofia/Escritorio")
```

### 3. Operaciones

### 3.1. Aritméticas

```{r, eval = FALSE}
a <- 1
b <- 2

a + b
a - b
a / b
a*b
a**2
a %% b
a %/% b


# Paréntesis
(a + b) / b
```

### 3.2. Lógicas

#### Operadores

```{r, eval=FALSE}
a > b
a == b
a != b
```

#### Álgebra de eventos

```{r, eval = FALSE}
c <- TRUE
d <- FALSE

c|d
c&d
```

### 4. Tipo de datos

R maneja 4 tipos de datos principales: `string (cadena de texto)`, `integer`, `numeric`, `booleano`.

```{r}
string <- "Hola, ¿Qué tal?"
entero <- 1L
numerico <- 0.5
booleano <- TRUE
perdido <- NA
no_existe <- NULL
```

-   Existen otros tipos de datos como `fechas (Date)` y `complejos`, pero de momento veremos estos tipos de datos.

-   Para confirmar ante qué tipo de datos estamos, puedo aplicar la función `class`.

-   También puedo confirmar un tipo de dato específico.

```{r}
class(string)
is.character(string)
```

-   También puedo transformar (coercionar) la clase de una variable:

```{r, eval = FALSE}
as.numeric(string)
as.character(entero)
```

```{r, echo = FALSE}
as.numeric(string)
as.character(entero)
```

### 5. Estructuras de datos

```{r}
vectores <- c(1, 2, 3, 4, 5)
matrices <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2, nrow = 3)
data_frame <- data.frame(variable_1 = c(1, 2, 3),
                         variable_2 = c(4, 5, 6))
listas <- list(data_frame, vectores, matrices)
array <- array(1:6, c(1,2,3))
```

------------------------------------------------------------------------

#### 5.1. Vectores

$$
\vec{v} = \left( \matrix{x_1 \\ x_2 \\ x_3 \\ \dots \\ x_i} \right)
$$

Los vectores son arreglos de una sola dimensión que coleccionan elementos de un solo tipo:

```{r}
vector_1 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
vector_2 <- c("a", "b", "c")

```

Puedo concatenar dos vectores:

```{r}
vector_m <- rep(1, times = 5)
vector_n <- rep(0, times = 5)
c(vector_m, vector_n)
```

#### 5.1.1. Dimensionalidad e índices

Con la función `length`, observamos la cantidad de elementos.

```{r}
length(vector_1)
```

Con corchetes cuadrados consultamos sus índices:

```{r, eval = FALSE}
vector_1[2]
vector_1[2] <- 3
vector_1
vector_1[1:3]
```

```{r, echo = FALSE}
vector_1[2]
vector_1[2] <- 3
vector_1
vector_1[1:3]
```

#### Vectores con secuencias específicas

```{r}
secuencia_2 <- seq(from = 1, to = 5, by = 0.1)
secuencia_repetitiva <- rep(5, 10)
x <- rnorm(100, mean = 4, sd = 1.2)
```

#### 5.1.2. Operaciones con vectores

Los vectores son suceptibles a **operaciones aritméticas** entre un vector y una constante:

```{r, eval = FALSE}
vector_1 + 1
vector_1 / 2
```

```{r, eval = FALSE}
vector_2 <- 1:3

vector_1 ; vector_2

vector_1 + vector_2
vector_1 / vector_2
```

También es posible aplicar **operaciones lógicas**:

```{r, eval = FALSE}
## Lógicas
vector_2
vector_2 > 2
vector_2 >= 2
vector_1 != 3
```

```{r, echo = FALSE}
## Lógicas
vector_2
vector_2 > 2
vector_2 >= 2
vector_1 != 3
```

#### 5.1.3. Clases rígidas como propiedad de los vectores

```{r}
vector_3 <- c(1, 2, 3, 4)
class(vector_3)

vector_4 <- c(1, 2, 3, "Hola")
vector_4

class(vector_4)
```

#### Coerción: ejemplo con vectores

-   **Coerción explícita:** es cuando se aplica una función (generalmente, del tipo: `as.numeric()`) para cambiar la naturaleza de la variable:

```{r, eval = FALSE}
vector_bool <- c(TRUE, FALSE)
vector_bool

vector_enteros <- as.numeric(vector_bool)
vector_enteros

as.character(vector_enteros)
as.character(vector_bool)
```

```{r, echo = FALSE}
vector_bool <- c(TRUE, FALSE)
vector_bool

vector_enteros <- as.numeric(vector_bool)
vector_enteros

as.character(vector_enteros)
as.character(vector_bool)
```

-   **Coerción implícita:** cuando R modifica de maenra automática y forzosa la naturaleza de los datos.

    -   Objetos con restrcciones:

```{r, eval = FALSE}
c(1, 2, 3, "Hola")
c(1, 2, 3, TRUE)
```

```{r, echo = FALSE}
c(1, 2, 3, "Hola")
c(1, 2, 3, TRUE)
```

> ##### Jerarquía de la coerción
>
> -   La jerarquía de la coerción es la siguiente:
>
>     `bool > entero > numérico > texto (string)`

------------------------------------------------------------------------

#### 5.2. Matrices

$$
A_{ij} = \left( \matrix{a_{11} & a_{12} & \dots & a_{1j} \\
a_{21} & a_{22} & \dots & a_{2j} \\ 
\vdots & \vdots & \vdots & \vdots\\
a_{i1} & a_{i2} & \dots & a_{ij}} \right)
$$

```{r}
matriz_0 <- matrix(c(1, 2, 3, 4, 5, 6))
matriz_1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 2)
```

-   **Propuesto.** Haga la siguiente matriz:

$$
A = \left( \matrix{1 & 2 & 3 \\ 4 & 5 & 6} \right)
$$

#### Funciones `cbind` y `rbind`.

```{r}
vector_1 <- 1:5
vector_2 <- rep(1, times = 5)
vector_3 <- seq(2, 10, by = 2)

# Vectores como columnas
matriz_3 <- cbind(vector_1, vector_2, vector_3)

# Vectores como filas
matriz_4 <- rbind(vector_1, vector_2, vector_3)
```

#### 5.2.1. Dimensionalidad e índice

```{r, eval = FALSE}
dim(matriz_3)
```

```{r, echo = FALSE}
dim(matriz_3)
```

```{r, eval = FALSE}
# Índice
matriz_3[1, 1]
matriz_3[2,]
matriz_3[, 2]

matriz_3[, 2] <- rep(2, 5)
matriz_3
```

-   **Propuesto:** ¿cómo añadir un vector_4 que sea el resultado de vector_3 - 1?

#### 5.2.2. Operaciones con matrices

```{r, eval = FALSE}
matriz_a <- matrix(1:4, ncol = 2)
matriz_b <- matrix(1:4, ncol = 2)

matriz_a + matriz_b
matriz_a * matriz_b
matriz_a %*% matriz_b
```

```{r, echo = FALSE}
matriz_a <- matrix(1:4, ncol = 2)
matriz_b <- matrix(1:4, ncol = 2)

matriz_a + matriz_b
matriz_a * matriz_b
matriz_a %*% matriz_b
```

#### Coerción implícita en matrices

```{r, eval = FALSE}
## Tipo de dato
matrix(c(1, 2, 3, TRUE), ncol = 2)
matrix(c(1, 2, 3, "Hola"), ncol = 2)

vector_a1 <- 5:3
vector_a2 <- c("Chile", "Argentina", "Bolivia")

cbind(vector_a1, vector_a2)

```

```{r, echo = FALSE}
## Estructua
matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 3)

vector_a1 <- c(1, 2, 3)
vector_a2 <- c(1, 2, 3, 4)

cbind(vector_a1, vector_a2)
```

------------------------------------------------------------------------

#### 5.3. Data Frame

------------------------------------------------------------------------

#### 5.4. Otras estructuras

------------------------------------------------------------------------

### 6. Funciones

### 7. Documentación

### 8. Consideraciones finales
