---
title: "Tutoría 1: Análisis de Datos"
format: html
editor: visual
theme: darkly
---

## R como entorno de desarrollo

-   **R** es un lenguaje de programación enfocado únicamente para estadística.\

-   \\\*\*\*

-   Cuando ustedes usan R (logo de R), están viendo la calculadora que hace lso cálculso por detrás, pero el programa que vamos a usar para trabajar en R es Rstudio, por qué? POr comodidad, Rstudio tiene diferentes ventanas que nos van a decir qué bases de datos tenemos cargadas, qué objetos hemos generado y una ventana para visualizar los gráficos.

    -   Consola: este gran panel que vemos aquí es la consola. En esta.

        -   Siles aparece el signo "+", es porque o no cerarron un paréntesis, o no cerraron comillas o están escribiendo un bloque de código (i.e. bucle for).

    -   Script: (describe el proceso de abrir un script) me sirve para ir dejando registro de lo que voy haciendo. Apreto ctrl + Enter para enviarloa la consola.

        -   Es script es el archivo principal de R, de un lenguaje de programación en general. ES en donde vana a estar las instrucciones, es decir todas las acciones, que yo voy a dejar registradas.

        -   Aquí es en donde voy a realizar el código de esta tutoría.

    -   Describe el resto de ventanas ...

-   **Rstudio** es el entorno de trabajo (IDLE) que tiene las herramientas necesarias para hacer **análisis de datos en R**.

-   Cuando se trabaja con **R**, por lo general, trabajamos con **Rstudio**.

    ## Primeros pasos

    **Comentarios** los comentarios son mensajes que yo dejo en el código.

    No se ejecuta y sirve para ir documentando mi código.

    ```{r}
    # Esto es un comentario
    ```

-   Miren, quiero que pongan atención al código de R de un investigador.

-   Con el investigador, no nos conocemos, pero me está narrando, muy brevemente, qué está haciendo con su código. Eso es muy buena práctica.

-   Otro tip, que yo suelo usar arto, es que con el comando ctrl + shift + r puedes hacer un header.

-   Luego, puedes paretar ctrl + shift + o y aparece un outline.

-   Otra buena práctica, es iniciarel script con

    ```{r}
    rm(list = ls())
    ```

    Lo primero que tienen que saber, es que R es un lenguaje orientado a objetos.

-   Con el operador "\<-" asigno un valor, estructura de datos, incluso función, a un objeto.

-   Puedo almacenar cosas en lso objetos y después, puedo llamarlas.

    ```{r}
    pi <- 3.14
    radio <- 2

    radio*pi**2
    ```

    -   Se almacenan en la memoria RAM (temporal) del computador.

        Cosas más complejas vamos a ir almacenando en objetos a medida de que avance al taller, estructuras de datos, como vectores, matrices, etc,

    -   La idea, es que los nombres de los objetos, sean descriptivos y breves.

    -   No puedo utilizar espacios entreedio.

    -   No puedo utilizar nombres

    -   Protocolos para nombrar objetos:

        -   snake_case

        -   camelCase

    -   Flujo de ejecución vertical, de arriba hacia abajo.

        -   Puedo usar `;` para poenr dos instrucciones en una misma línea.

    ### Fijar el directorio

    ```{r}
    getwd()
    setwd("/home/sofia")
    ```

## Operaciones

### Aritméticas

```{r}
a <- 1
b <- 2

a + b
b - a
a / b
a*b
a**2
a %% b # módulo o residuo
a %/% b # división entera
```

### Lógicas

```{r}
a > b
a >= b
a == b
a != b
```

### Álgrbra de eventos

#### Desafío: ¿Cómo puedo comprobar que un número es par?

```{r}

```

## Tipos de datos

```{r}
texto <- "Hola Alumnos"
entero <- 1L
numérico <- 0.5 # ¿cómo se distinguen?
booleano <- TRUE
perdido <- NA
```

### Comprobar el tipo de dato

## Estructuras de Datos

Preséntalos.

### Vectores

```{r}
vector <- c(1, 2, 3, 5, 6, 7, 8, 9)
vector
```

Es una estuctura de datos que coleccionean objetos del mismo tipo, con una sola dimensión: el largo.

```{r}
length(vector)
```

Puedo consultar sus valores con corchetes (índice):

```{r}
vector[2]

# Reemplazar
vector[2] <- 3
vector
```

#### Generación de vectores con patrones definidos

```{r}
sequencia <- 1:5
secuencia <- seq(1, 5)
secuencia_repetitiva <- rep(10, 5)
x <- rnorm(100, mean = 4, sd = 1.2) # X ~ N(4, 1.2)
```

#### Operaciones

```{r}
vector_1 <- c(1, 2, 3, 4, 5)
vector_2 <- c(6, 7, 8, 9, 10)

vector_1 + vector_2
```

Operaciones lógicas

```{r}
vector_1 > 3
vector_1 >= 3
```

-   El **vector** solo puede tener un **tipo de dato**. (pásalo rápido)

```{r}
vector_3 <- c(1, 2, 3, 4, 5)
class(vector)

vector_4 <- c(1, 2, 3, "Hola")
vector_4
class(vector_4)
```

Esta es la jerarquía de los valores:

`lógico -> entero -> numérico -> cadena de texto` (`logical -> integer -> numeric -> character`)

```{r}
vector_bool <- c(TRUE, FALSE)
vector_bool
vector_enteros <- as.integer(vector_bool)
vector_enteros

vector_numericos <- as.numeric(vector_enteros)
vector_numericos

vector_numericos_2 <- as.numeric(vector_bool)
vector_numericos_2
```

-   Entonces, bajo la misma lógica de que los vectores solo pueden tener un solo tipo de dato, pueden suceder estas lecturas:

```{r}
c(1, 2, 3, TRUE)
```

-   Y cualquier cosa puede ser convertida en un valor de texto, porque cualquier cosa puede ser escrita como una palabra.

<!-- -->

-   **Coerción implícita.** R realizó una operación de manera forzosa y "por debajo", que transformó la naturaleza de los datos.

    -   Clase de la variable.

    -   Número de elementos.

```{r}
c(1, 2, 3, "Hola")

vector_a <- c(1, 1, 1, 1, 1)
vector_b <- c(1, 2, 3)

vector_a + vector_b
```

-   La coerción implícita suele ser más un problema que una solución.

-   **Coerción explícita.** Usé una función de tipo `as.numeric` para transformar o coercionar la naturaleza de los datos.

```{r}
vector_booleano <- c(TRUE, FALSE, TRUE, TRUE)
as.numeric(vector_booleano)
```

-   ¿Cuál es el tipo de dato correcto para mi vector?

    -   El tipo de dato que corresponde a la medición adecuada.
    -   Esto es relevante, porque cuando tengan una base de datos, ustedes deben hacer este proceso.

------------------------------------------------------------------------

### Matrices

```{r}
matriz_1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 2)
matriz_1

matriz_1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 3)
matriz_1

matriz_1 <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 3)
matriz_1

matriz_1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, byrow = TRUE)
matriz_1


vector_1 <- 1:5
vector_2 <- rep(4, times = 5)
vector_3 <- seq(2, 10, by = 2)
matriz_2 <- cbind(vector_1, vector_2, vector_3)
matriz_2
```

-   Las matrices tienen dos dimensiones:

    $$
    A_{ij} = \left( \matrix{a_{11} & a_{12} & \dots & a_{1j} \\
    a_{21} & a_{22} & \dots & a_{2j} \\ 
    \vdots & \vdots & \vdots & \vdots\\
    a_{i1} & a_{i2} & \dots & a_{ij}} \right)
    $$

    ```{r}
    matriz_2
    dim(matriz_2)
    ```

-   Consultar el índice:

    -   Aquí ya empieza a preguntar:

```{r}
matriz_2[1,1]
matriz_2[5,3]
matriz_2[1,]
matriz_2[,2]
matriz_2[,2] <- matriz_2[,2] - 1 # puedo poner un vector de la misma longitud
matriz_2
matriz_2[,2] <- as.character(matriz_2[,2])
matriz_2
```

-   Operaciones entre matrices

```{r}
matriz_a <- matrix(1:4, ncol = 2)
matriz_b <- matrix(1:4, ncol = 2)

matriz_a + matriz_b
matriz_a * matriz_b
matriz_a %*% matriz_b
diag(matriz_a)
```

-   Las matrices, al igual que los vectores, solo pueden tener un tipo de dato. (no incluir:)

```{r}
matrix(c(1, 2, 3, 4, 5, TRUE), ncol = 2)
matrix(c(1, 2, 3, 4, 5, "Hola"), ncol = 2)
```

```{r}
vector_col1 <- c(1, 2, 3)
vector_col2 <- c("Hola", "¿Cómo estás?", "Adiós.")

cbind(vector_col1, vector_col2)
```

-   A pesar de que son dos columnas que yo estoy poneindo de manera independiente, aun así me pone todo con texto. (**Coerción implícita**)

-   También, si las columnas que pongo, difieren en términos de dimensiones, se crea una coerción implícita. (poner rápidamente:)

```{r}
cbind(c(1,2,3), c(1, 2, 3, 4))
```

### Data frames

-   Las data.frames son los marcos de datos, son objetos que contienen variables en una estructura de base de datos relacional.

-   Es el objeto que es reconocido por R como bases de datos.

    -   Pueden almacenar variables de todo tipo: tanto discretas como continuas.

Podemos hacer una data.frame a mano con la función data.frame(). (al igual que c() para vector); también puedo poner los vectores por afuera.

```{r}
data <- data.frame(edad = c(24, 60, 15, 31, 56, 70, 23, 44),
                   sexo = c(1, 0, 0, 1, 0, 0, 1, 1),
                   nivel_educacional = c("Básica", "Universitaria", "Media", "Posgrado", "Posgrado", "Básica", "Media", "Posgrado"))
```

Importar variables

```{r}
library(readxl)
data <- read_excel("datos.xlsx")
```

-   Poner énfasis en el directorio.

### Exploración de la base de datos

```{r}
dim(data)
head(data)
tail(data)
str(data)
```

### Consultar variables

-   Las variables son vectores.

```{r}
data[,1]
data$edad
data$agno <- rep(2023, 8)
data$agno_nacimiento <- data$agno - data$edad
```

-   Filtros

```{r}
data[1,]

# Filtros por filas

## Muéstrame las columnas de los mayores de edad
data[data$edad > 18,]
```

### Listas

-   

### Arrays

### Cohersión

## Funciones

-   Resulta que cada vector de cada dataframe, es un vector.

### Bases de Datos
